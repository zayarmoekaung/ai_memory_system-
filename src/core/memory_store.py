import chromadb\nfrom typing import List, Dict, Any\nfrom ..config.settings import settings # Updated import path\n\nclass MemoryStore:\n    def __init__(self):\n        \"\"\"\n        Initializes the MemoryStore by setting up the ChromaDB client and collections.\n        It manages both the main memory chunks and a separate collection for associative links.\n        The database path and collection names are fetched from the application settings.\n        \"\"\"\n        self.client = chromadb.PersistentClient(path=str(settings.CHROMA_DB_PATH))\n        # Main collection for memory chunks\n        self.collection = self.client.get_or_create_collection(name=settings.CHROMA_COLLECTION_NAME)\n        # Additional collection for associative links (e.g., entity-chunk relationships)\n        self.associative_collection = self.client.get_or_create_collection(name=settings.CHROMA_ASSOCIATIVE_COLLECTION_NAME)\n\n\n    def add_memory_chunk(self, chunk_id: str, content: str, embedding: List[float], metadata: Dict[str, Any]):\n        \"\"\"\n        Adds a single memory chunk to the ChromaDB collection.\n\n        Args:\n            chunk_id (str): A unique identifier for the memory chunk.\n            content (str): The textual content of the memory chunk.\n            embedding (List[float]): The vector embedding of the chunk\'s content.\n            metadata (Dict[str, Any]): A dictionary of associated metadata (e.g., timestamp, importance_score,\n                                  source_id, associated_entities, emotional_valence, vividness_score,\n                                  context_tags, event_sequence_id, original_text_start_index).\n        \"\"\"\n        try:\n            self.collection.add(\n                documents=[content],\n                embeddings=[embedding],\n                metadatas=[metadata],\n                ids=[chunk_id]\n            )\n        except Exception as e:\n            print(f\"Error adding memory chunk {chunk_id}: {e}\")\n            raise\n\n    def search_memories(self, query_embedding: List[float], n_results: int = 5, min_distance: float = 0.5) -> List[Dict[str, Any]]:\n        \"\"\"\n        Performs a similarity search in ChromaDB using a query embedding.\n\n        Args:\n            query_embedding (List[float]): The embedding of the query.\n            n_results (int): The maximum number of results to return.\n            min_distance (float): The minimum distance (e.g., 0.0 to 2.0 for cosine distance) for filtering results.\n                                  Lower distance means higher similarity. Currently, ChromaDB uses L2 distance by default.\n                                  This parameter would typically be used to filter out less relevant results.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries, where each dictionary contains\n                                  \'id\', \'content\', \'embedding\', \'metadata\', and \'distance\' for a retrieved chunk.\n        \"\"\"\
        try:\n            results = self.collection.query(\n                query_embeddings=[query_embedding],\n                n_results=n_results,\n                # where={\'$and\': [{\'distance\': {\'$lt\': min_distance}}]},\n                # ChromaDB does not directly support distance filtering in query() with L2 distance as readily as cosine.\n                # We will filter post-query if needed or adjust based on distance metric.\n                # For now, simply return results and let higher-level logic handle relevance filtering.\n                include=[\'documents\', \'embeddings\', \'metadatas\', \'distances\']\n            )\n\n            formatted_results = []\n            if results and results[\'ids\'] and results[\'ids\'][0]:\n                for i in range(len(results[\'ids\'][0])):\n                    formatted_results.append({\n                        \'id\': results[\'ids\'][0][i],\n                        \'content\': results[\'documents\'][0][i],\n                        \'embedding\': results[\'embeddings\'][0][i],\n                        \'metadata\': results[\'metadatas\'][0][i],\n                        \'distance\': results[\'distances\'][0][i]\n                    })\n            return formatted_results\n        except Exception as e:\n            print(f\"Error searching memories: {e}\")\n            return []\n\n    def get_memory_by_id(self, chunk_id: str) -> Dict[str, Any]:\n        \"\"\"\n        Retrieves a specific memory chunk by its unique identifier.\n\n        Args:\n            chunk_id (str): The unique identifier of the memory chunk.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing the chunk\'s \'id\', \'content\', \'embedding\', and \'metadata\',\n                            or an empty dictionary if not found.\n        \"\"\"\
        try:\n            result = self.collection.get(ids=[chunk_id], include=[\'documents\', \'embeddings\', \'metadatas\'])\n            if result and result[\'ids\'] and result[\'ids\'][0]:\n                return {\n                    \'id\': result[\'ids\'][0],\n                    \'content\': result[\'documents\'][0],\n                    \'embedding\': result[\'embeddings\'][0],\n                    \'metadata\': result[\'metadatas\'][0]\n                }\n            return {}\n        except Exception as e:\n            print(f\"Error retrieving memory {chunk_id}: {e}\")\n            return {}\n\n    def delete_collection(self, collection_name: str = None):\n        \"\"\"\n        Deletes a specified ChromaDB collection or the main memory collection by default.\n        Use with caution, primarily for testing or resetting the memory store.\n\n        Args:\n            collection_name (str, optional): The name of the collection to delete. If None, deletes the main memory collection.\n        \"\"\"\
        collection_to_delete = collection_name if collection_name else settings.CHROMA_COLLECTION_NAME\n        try:\n            self.client.delete_collection(name=collection_to_delete)\n            print(f\"Collection \'{collection_to_delete}\' deleted.\")\n            # Re-initialize collection after deletion to ensure it\'s ready for new data\n            if collection_to_delete == settings.CHROMA_COLLECTION_NAME:\n                self.collection = self.client.get_or_create_collection(name=settings.CHROMA_COLLECTION_NAME)\n            elif collection_to_delete == settings.CHROMA_ASSOCIATIVE_COLLECTION_NAME:\n                self.associative_collection = self.client.get_or_create_collection(name=settings.CHROMA_ASSOCIATIVE_COLLECTION_NAME)\n        except Exception as e:\n            print(f\"Error deleting collection {collection_to_delete}: {e}\")\n            raise\n\n# Example usage (for testing purposes)\nif __name__ == \"__main__\":\n    # This part assumes settings are correctly loaded (e.g., via .env or default values)\n    print(f\"ChromaDB will persist to: {settings.CHROMA_DB_PATH}\")\n    memory_store = MemoryStore()\n\n    # Ensure collection is empty for a clean test run\n    # Uncomment the following line to clear the database for each run if needed\n    # memory_store.delete_collection()\n    # memory_store.delete_collection(settings.CHROMA_ASSOCIATIVE_COLLECTION_NAME)\n\n    from uuid import uuid4\n    import time\n\n    # Add a memory chunk with enhanced metadata\n    chunk_id_1 = str(uuid4())\n    content_1 = \"The quick brown fox jumps over the lazy dog.\"\n    # For testing, we can use a dummy embedding if EmbeddingManager is not yet integrated\n    dummy_embedding_1 = [0.1] * 384  # Assuming 384 dimensions for all-MiniLM-L6-v2\n    metadata_1 = {\n        \"timestamp\": time.time(),\n        \"importance_score\": 0.8,\n        \"source_id\": \"test_source_1\",\n        \"original_text_start_index\": 0,\n        \"associated_entities\": [\"fox\", \"dog\"], # New metadata\n        \"emotional_valence\": 0.2, # New metadata\n        \"vividness_score\": 0.7, # New metadata\n        \"context_tags\": [\"animal\", \"action\"], # New metadata\n        \"event_sequence_id\": \"event_abc\"\n    }\n    memory_store.add_memory_chunk(chunk_id_1, content_1, dummy_embedding_1, metadata_1)\n    print(f\"Added memory chunk 1: {chunk_id_1}\")\n\n    chunk_id_2 = str(uuid4())\n    content_2 = \"The dog is very lazy and sleeps all day.\"\n    dummy_embedding_2 = [0.2] * 384\n    metadata_2 = {\n        \"timestamp\": time.time() - 3600,\n        \"importance_score\": 0.6,\n        \"source_id\": \"test_source_1\",\n        \"original_text_start_index\": len(content_1) + 1,\n        \"associated_entities\": [\"dog\", \"sleep\"], # New metadata\n        \"emotional_valence\": 0.0,\n        \"vividness_score\": 0.4,\n        \"context_tags\": [\"animal\", \"state\"],\n        \"event_sequence_id\": \"event_abc\"\n    }\n    memory_store.add_memory_chunk(chunk_id_2, content_2, dummy_embedding_2, metadata_2)\n    print(f\"Added memory chunk 2: {chunk_id_2}\")\n\n    # Search for memories (using a dummy query embedding for now)\n    query_embedding = [0.15] * 384\n    print(\"\\nSearching for memories...\")\n    found_memories = memory_store.search_memories(query_embedding, n_results=2)\n    for mem in found_memories:\n        print(f\"  ID: {mem[\'id\']}, Content: {mem[\'content\']}, Distance: {mem[\'distance\']:.4f}\")\n        print(f\"    Metadata: {mem[\'metadata\']}\")\n\n    # Retrieve a specific memory\n    print(f\"\\nRetrieving memory by ID: {chunk_id_1}\")\n    retrieved_memory = memory_store.get_memory_by_id(chunk_id_1)\n    if retrieved_memory:\n        print(f\"  Found: {retrieved_memory[\'content\']}\")\n        print(f\"    Metadata: {retrieved_memory[\'metadata\']}\")\n    else:\n        print(\"  Memory not found.\")\n\n    # Test deleting the collection (use with caution)\n    # print(\"\\nDeleting collection...\")\n    # memory_store.delete_collection(settings.CHROMA_COLLECTION_NAME)\n    # memory_store.delete_collection(settings.CHROMA_ASSOCIATIVE_COLLECTION_NAME)\n    # print(\"Searching main collection after deletion...\")\n    # found_memories_after_delete = memory_store.search_memories(query_embedding, n_results=2)\n    # print(f\"Found memories: {len(found_memories_after_delete)}\")\n